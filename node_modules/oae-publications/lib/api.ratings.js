/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var log = require('oae-logger').logger('oae-publications');
var Validator = require('oae-util/lib/validator').Validator;

var PublicationsAPI = require('./api.publications');
var PublicationsDAO = require('./internal/dao');
var PublicationsRatingsDAO = require('./internal/dao.ratings');
var PublicationsValidator = require('./validator').Validator;
var Rating = require('./model').Rating;

/**
 * Register a listener in the publications API for when a publication has been created
 */
PublicationsAPI.registerPublicationsDecorator('rating', function(ctx, publications, callback) {
    return _decoratePublicationsWithRatings(ctx, publications, callback);
});

/**
 * Rate a publication
 *
 * @param  {Context}        ctx                     The current context
 * @param  {String}         publicationId           The id of the publication that receives a rating
 * @param  {Number}         rating                  The rating value
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error object containing error code and error message
 * @param  {Publication}    callback.publication    Object representing the publication that received a rating
 */
var ratePublication = module.exports.ratePublication = function(ctx, publicationId, rating, callback) {
    var validator = new PublicationsValidator();
    validator.check(publicationId, {'code': 400, 'msg': 'Missing publication ID'}).notEmpty();
    validator.check(publicationId, {'code': 400, 'msg': 'Invalid or malformed publication ID'}).isPublicationId();
    validator.check(rating, {'code': 400, 'msg': 'Missing rating'}).notEmpty();
    validator.check(rating, {'code': 400, 'msg': 'Invalid rating data type'}).isInt();
    rating = parseInt(rating);
    validator.check(rating, {'code': 400, 'msg': 'Rating should minimum be 1'}).min(1);
    validator.check(rating, {'code': 400, 'msg': 'Rating should maximum be 5'}).max(5);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the publication exists
    PublicationsDAO.getPublication(publicationId, function(err, publication) {
        if (err) {
            log().error({'err': err, 'publicationId': publicationId, 'rating': rating}, 'Error while rating publication');
            return callback(err);
        }

        // Check if the user is authorized to rate the publication
        _isAllowedToRate(ctx, publicationId, function(err, isAllowed) {
            if (err) {
                log().error({'err': err, 'publicationId': publicationId, 'rating': rating}, 'Error while checking permissions');
                return callback(err);
            }

            if (!isAllowed) {
                log().error({'code': 401, 'msg': 'Only authorized users are allowed to rate a publication'}, 'Error while rating publication');
                return callback({'code': 401, 'msg': 'Only authorized users are allowed to rate a publication'});
            }

            // Rate the publication
            var userId = ctx.user().id;
            PublicationsRatingsDAO.updatePublicationRating(publicationId, rating, userId, function(err, rating) {
                if (err) {
                    log().error({'err': err, 'publicationId': publicationId, 'rating': rating}, 'Error while rating publication');
                    return callback(err);
                }

                // Return the rating
                return getRating(ctx, publicationId, callback);
            });
        });
    });
};

/**
 * Get the rating for a publication
 *
 * @param  {Context}        ctx                     The current context
 * @param  {String}         publicationId           The id of the publication where the rating is requested for
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error object containing error code and error message
 * @param  {Rating[]}       callback.ratings        Collection of objects representing the rating of a publication
 */
var getRating = module.exports.getRating = function(ctx, publicationId, callback) {
    var validator = new PublicationsValidator();
    validator.check(publicationId, {'code': 400, 'msg': 'Missing publication ID'}).notEmpty();
    validator.check(publicationId, {'code': 400, 'msg': 'Invalid or malformed publication ID'}).isPublicationId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    PublicationsRatingsDAO.getPublicationsRatings([publicationId], function(err, ratings) {
        if (err) {
            log().error({'err': err, 'publicationId': publicationId}, 'Error while fetching publication rating');
            return callback(err);
        }

        // Decorate the rating with the user permissions
        _isAllowedToRate(ctx, publicationId, function(err, isAllowed) {
            if (err) {
                log().error({'err': err}, 'Error while decorating rating');
                return callback(err);
            }

            // Return the decorated rating
            ratings[0].isAllowed = isAllowed;
            return callback(null, ratings[0]);
        });
    });
};

//////////////////////////
//  INTERNAL FUNCTIONS  //
//////////////////////////

/**
 * Decorates a publication
 */
var _decoratePublicationsWithRatings = function(ctx, publications, callback) {

    // Filter the publication ID's from the collection
    var publicationIds = _.pluck(publications, 'id');

    // Request the ratings corresponding to the publication ID's
    PublicationsRatingsDAO.getPublicationsRatings(publicationIds, function(err, ratings) {
        if (err) {
            log().error({'err': err, 'publicationIds': publicationIds}, 'Error while fetching publications ratings');
            return callback(err);
        }

        // Decorate each publication with its corresponding rating object
        _.each(publications, function(publication) {
            var rating = _.find(ratings, function(rating) { return rating.publicationId === publication.id; });
            if (!rating) {
                rating = new Rating(publication.id, 0, 0);
            }
            publication.rating = rating;
        });

        // Check if the user already rated the publication
        _hasAlreadyVoted(ctx.user().id, publicationIds, function(err, publicationIds) {
            if (err) {
                log().error({'err': err, 'publicationIds': publicationIds, 'userId': ctx.user().id}, 'Error while checking if user is allowed to rate a publication');
                return callback(err);
            }

            // Decorate the rating with whether or not the user is allowed to rate the publication
            _.each(publications, function(publication) {
                publication.rating.isAllowed = _.isEmpty(_.find(publicationIds, function(id) { return id === publication.id; }));
                console.log(publication);
            });

            // Return the decorated publications
            return callback(null, publications);
        });
    });
};

/**
 * Returns whether or not a user has already rated a publication
 *
 * @param  {String}         userId                  The ID of the user where
 * @param  {String}         publicationIds          A collection of publication IDs
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error object containing error code and error message
 * @param  {Object}         callback.publications   Object containing permissions per publication
 * @api private
 */
var _hasAlreadyVoted = function(userId, publicationIds, callback) {
    PublicationsRatingsDAO.getUserPublicationsRatings(publicationIds, userId, function(err, publicationIds) {
        if (err) {
            return callback(err);
        }

        return callback(null, publicationIds);
    });
};

/**
 * Checks whether or not a user is authorized to rate a publication
 *s
 * @param  {Context}        ctx                     The current context
 * @param  {String}         publicationId           The id of the publication where the authorization needs to be checked for
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error object containing error code and error message
 * @param  {Boolean}        callback.isAllowed      Whether or not the current user is allowed to rate a publication
 * @api private
 */
 var _isAllowedToRate = function(ctx, publicationId, callback) {
    if (!ctx.user()) {
        return callback(null, false);
    }

    // Check if the user already rated the publication
    _hasAlreadyVoted(ctx.user().id, [publicationId], function(err, publicationIds) {
        if (err) {
            log().error({'err': err, 'publicationId': publicationId, 'userId': ctx.user().id}, 'Error while checking if user is allowed to rate a publication');
            return callback(err);
        }

        var isAllowed = _.isEmpty(publicationIds);
        return callback(null, isAllowed);
    });
 };
