/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var log = require('oae-logger').logger('oae-publications');
var Validator = require('oae-util/lib/validator').Validator;

var AuthenticationAPI = require('oae-authentication');
var AuthenticationDAO = require('oae-authentication/lib/internal/dao');
var AuthzUtil = require('oae-authz/lib/util');
var ContentAPI = require('oae-content');
var ContentDAO = require('oae-content/lib/internal/dao').Content;
var ContentUtil = require('oae-content/lib/internal/util');
var ConfigAPI = require('oae-config');
var OaeUtil = require('oae-util/lib/util');
var PrincipalsUtil = require('oae-principals/lib/util');

var PublicationsConfig = ConfigAPI.config('oae-publications');
var PublicationsConstants = require('./constants').PublicationsConstants;
var PublicationsDAO = require('./internal/dao');
var PublicationsEmitter = require('./internal/emitter');
var PublicationsUtil = require('./util');
var PublicationsValidator = require('./validator').Validator;

var createPublicationListeners = {};
var publicationsProfileDecorators = {};

/**
 * Function that registers a listener that needs to be executed when a publication is created.
 * In this case, we want to use the listener to create a ticket before the created publication is returned.
 *
 *  * When the `oae-tickets` module is initialized, a listener is registered in this (`oae-publications`) module:
 *  *
 *  * createPublicationsListeners = {
 *  *     'ticket': [Function]
 *  * };
 *  *
 *  * After the ticket is created, we decorate the created publication with the created ticket.
 *  * This is a multi-step process, but we want to return the created ticket (especially the external, user-friendly ticket ID) together with the created publication in the same request.
 *  *
 *  * When requesting a publication, we execute the listener. The publication is passed in as a parameter and gets decorated with its linked ticket:
 *  *
 *  * createPublicationListeners[namespace](ctx, publication, function(err) {
 *  *    ...
 *  * });
 *  *
 *  * After all the listeners have been executed, the created, decorated publication is returned:
 *  *
 *  * return callback(null, publication, result);
 *
 * @param  {String}         namespace                   The unique namespace for the listener
 * @param  {Function}       fn                          The function that needs to be executed when the listener is executed
 * @param  {Context}        fn.ctx                      The context of the current request
 * @param  {Publication}    fn.publication              The created publication
 * @param  {Function}       fn.callback                 Standard callback function
 * @param  {Object}         fn.callback.err             Error object containg the error code and the error message
 */
var registerCreatePublicationListener = module.exports.registerCreatePublicationListener = function(namespace, fn) {
    if (createPublicationListeners[namespace]) {
        throw new Error(util.format('Attempted to register publication listener duplicate with namespace "%s"', namespace));
    } else if (!_.isFunction(fn)) {
        throw new Error(util.format('Attempted to register publication listener for namespace "%s" without a function', namespace));
    }

    createPublicationListeners[namespace] = fn;
};

/**
 * Register a decorator for the full publication profile.
 * In this case, the requested publication needs to be decorated with its linked ticket.
 *
 *  * When the `oae-tickets` module is initialized, a listener is registered in this (`oae-publications`) module:
 *  *
 *  * publicationsProfileDecorators = {
 *  *     'ticket': [Function]
 *  * };
 *  *
 *  * After the publication has been retrieved, all the decorators need to be executed. These are stored temporary untill the publication is returned:
 *  *
 *  * _.each(publicationsProfileDecorators, function(listener, namespace) {
 *  *     listener(ctx, publicationId, function(err, decorator) {
 *  *         decorators[namespace] = decorator;
 *  *         ...
 *  *     });
 *  * });
 *  *
 *  * When all the decorators have been executed, we return the created, decorated publication:
 *  *
 *  * return callback(null, _.extend(publication, decorators);
 *
 * @param  {String}         namespace                   The unique namespace for this decorator
 * @param  {Function}       decorator                   The function that will provide additional data for the publication profile
 * @param  {Context}        decorator.ctx               The context of the current request
 * @param  {Publication[]}  decorator.publications      The publications being decorated
 * @param  {Function}       decorator.callback          This function should be invoked with the decoration object when complete
 * @param  {Object}         decorator.callback.err      An error that occurred during decoration, if any
 * @param  {Object}         decorator.callback.data     The decoration data to bind to the publication profile
 */
var registerPublicationsDecorator = module.exports.registerPublicationsDecorator = function(namespace, decorator) {
    if (publicationsProfileDecorators[namespace]) {
        throw new Error(util.format('Attempted to register duplicate publication profile decorator with namespace "%s"', namespace));
    } else if (!_.isFunction(decorator)) {
        throw new Error(util.format('Attempted to register publication profile decorator for namespace "%s" without a decorator function', namespace));
    }

    publicationsProfileDecorators[namespace] = decorator;
};


//////////////////
//  INGESTION   //
//////////////////

/**
 * Exposes the ingester API with which ingesters can ingest and/or link publication.
 * The exposed functions on this object will bypass any security checks, so please ensure careful usage.
 */
var IngesterAPI = module.exports.IngesterAPI = {};

/**
 * Ingests a publication without performing any access checks.
 * This method is only intended to be used by Publication ingesters. Any other codepaths should use the `createPublication` method.
 *
 * @param  {String}         tenantAlias             The tenant alias
 * @param  {Publication}    publication             The publication to ingest
 * @param  {String[]}       sourceIds               An array of source identifiers
 * @param  {Function}       callback                Standard callback method
 * @param  {Object}         callback.err            Standard error object
 * @param  {Object}         callback.publication    The ingested publication
 * @param  {String}         callback.result         The result of the ingestion process. This will be one of `PublicationsConstants.ingestionResult` and will indicate whether the publication has been created, updated or ignored
 */
IngesterAPI.ingestPublication = function(tenantAlias, publication, sourceIds, callback) {
    var validator = new Validator();

    // Verify the publication object
    validator.check(null, {'code': 400, 'msg': 'Missing publication'}).isObject(publication);
    if (_.isObject(publication)) {
        // Check the required parameters
        var parameters = ['displayName', 'publicationType', 'date', 'authors'];
        _.each(parameters, function(parameter) {
            validator.check(publication[parameter], {'code': 400, 'msg': 'Missing ' + parameter}).notEmpty();
        });
        validator.check(publication.publicationType, {'code': 400, 'msg': 'Unknown publication type'}).isIn(_.values(PublicationsConstants.publicationTypes));
        validator.check(publication.date, {'code': 400, 'msg': 'The publication date is malformed'}).isInt();

        // Check that at least one author has been provided
        validator.check(null, {'code': 400, 'msg': 'Authors should be provided as an array'}).isArray(publication.authors);
        if (publication.authors) {
            validator.check(publication.authors.length, {'code': 400, 'msg': 'At least one author should be provided'}).min(1);
        }
    }
    // Verify the sources
    validator.check(sourceIds, {'code': 400, 'msg': 'Missing source IDs'}).isArray(sourceIds);
    if (_.isArray(sourceIds)) {
        validator.check(sourceIds.length, {'code': 400, 'msg': 'At least one source ID should be provided'}).min(1);

        _.each(sourceIds, function(sourceId) {
            validator.check(sourceId, {'code': 400, 'msg': 'Empty source IDs are not allowed`'}).notEmpty();
            validator.check(sourceId, {'code': 400, 'msg': 'A source ID should hold the form `<source name>#<id at source>`'}).contains('#');
        });
    }

    if (validator.hasErrors()) {
        log().error({'err': validator.getFirstError(), 'publication': publication, 'sourceIds': sourceIds}, 'Ingest publication validation error');
        return callback(validator.getFirstError());
    }

    // Check if a publication with this source ID already exists
    PublicationsDAO.getPublicationsBySourceIds(sourceIds, function(err, publicationsBySource) {
        if (err) {
            return callback(err);
        }

        // Get the uniq publications
        var publicationsById = {};
        _.each(publicationsBySource, function(publication) {
            publicationsById[publication.id] = publication;
        });
        var publications = _.values(publicationsById);

        // If nothing was found we're dealing with a publication that we've not seen before previously
        if (publications.length === 0) {
            PublicationsDAO.createPublication(tenantAlias, publication, sourceIds, function(err, createdPublication) {
                if (err) {
                    return callback(err);
                }
                return callback(null, createdPublication, PublicationsConstants.ingestionResult.CREATED);
            });

        // If we got a hit, we already ingested this publication (possible with another source ID though)
        // We try to update it and add our sources
        } else if (publications.length === 1) {
            PublicationsDAO.setSourceIds(publication, publications[0], sourceIds, function(err, updatedPublication) {
                if (err) {
                    return callback(err);
                }
                return callback(null, updatedPublication, PublicationsConstants.ingestionResult.UPDATED);
            });

        /*
         * This situation can occur when 2 harvesters ingested publications from different sources previously.
         * For example:
         *     - Harvester 1 ingests a publication harvested from arxiv
         *     - Harvester 2 ingests a publication harvested from pubmed
         *     - Harvester 3 (this one) ingests a publication that it knew was available on arxiv and pubmed (and possibly others)
         *
         * This is obviously a bit annoying. Especially if both publications are linked to different content items.
         * TODO: Check if they are linked to a piece of content.
         * If none of them are, or, if only one of them is, we can probably do a merge.
         * If more than 1 is linked, we have a problem.
         */
        } else if (publications.length > 1) {
            log().warn({'publication': publication, 'existingPublications': publications}, 'Found duplicate publications that could not be resolved automatically');
            return callback(null, publication, PublicationsConstants.ingestionResult.IGNORED);
        }
    });
};

/**
 * Links an OAE user to a publication. The authorname that is used in the set should be provided.
 * This does not necessarily have to be an exact match as some disambiguiation will be attempted.
 *
 * @param  {String}     publicationId   The publication to link the user to
 * @param  {String}     authorName      The name of the user as its stored in the external system/on the publication
 * @param  {String}     userId          The OAE user ID to link
 * @param  {Function}   callback        Standard callback function
 */
IngesterAPI.linkPublicationToUser = function(publicationId, authorName, userId, callback) {
    var validator = new Validator();
    _validatePublicationId(validator, publicationId);
    validator.check(authorName, {'code': 400, 'msg': 'Missing author name'}).notEmpty();
    validator.check(userId, {'code': 400, 'msg': 'Missing or invalid userId'}).isUserId();
    if (validator.hasErrors()) {
        log().error({'err': validator.getFirstError()}, 'Link publication to user validation error');
        return callback(validator.getFirstError());
    }

    PublicationsDAO.getPublication(publicationId, function(err, publication) {
        if (err) {
            return callback(err);
        }

        return _linkPublicationToUser(publication, authorName, userId, callback);
    });
};

/**
 * Links an OAE user to a publication. The authorname that is used in the set should be provided.
 * This does not necessarily have to be an exact match as some disambiguiation will be attempted.
 *
 * @param  {Publication}    publication         The publication to link the user to
 * @param  {String}         authorName          The name of the user as its stored in the external system/on the publication
 * @param  {String}         userId              The OAE user ID to link
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        Standard error object, if any
 * @param  {String}         callback.result     Result of the link operation. One of `PublicationsConstants.linkResult`
 * @api private
 */
var _linkPublicationToUser = function(publication, authorName, userId, callback) {
    // Ensure that is user is not already in the author set
    var isInAuthorSet = _.contains(publication.authors, userId);
    if (isInAuthorSet) {
        return callback(null, PublicationsConstants.linkResult.PRESENT);
    }

    var plainTextAuthors = _.filter(publication.authors, function(author) {
        return (typeof author === 'string' && !AuthzUtil.isUserId(author));
    });

    // Find the best match
    var index = PublicationsUtil.findAuthorInSet(authorName, publication.authors, 0.85);
    if (index === -1) {
        log().warn({'publication': publication, 'authorName': authorName, 'userId': userId}, 'Could not find the provided author in the set of authors linked to the publication, not linking');
        return callback(null, PublicationsConstants.linkResult.NOTFOUND);
    }
    var storedAuthorName = publication.authors[index];

    log().info({'publication': publication, 'authorName': authorName, 'storedAuthorName': storedAuthorName, 'userId': userId}, 'Linking publication to a user');
    PublicationsDAO.linkPublicationToUser(publication, storedAuthorName, userId, function(err) {
        if (err) {
            return callback(err);
        }

        return callback(null, PublicationsConstants.linkResult.LINKED);
    });
};

///////////////////
//  CREATE/EDIT  //
///////////////////

/**
 * Creates a publication if and only if the current user is an administrator on the tenant or users are allowed to
 * create their own publications.
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {Publication}    publication             The publication to create
 * @param  {Object}         [uploadedFile]          The uploaded file [optional]
 * @param  {String[]}       sourceIds               An array of source identifiers
 * @param  {Function}       callback                Standard callback method
 * @param  {Object}         callback.err            Standard error object
 * @param  {Object}         callback.publication    The ingested publication
 * @param  {String}         callback.result         The result of the ingestion process. This will be one of `PublicationsConstants.ingestionResult` and will indicate whether the publication has been created, updated or ignored
 */
var createPublication = module.exports.createPublication = function(ctx, publication, uploadedFile, sourceIds, callback) {
    if (!ctx.user()) {
        return callback({'code': 401, 'msg': 'Only authorized users are allowed to create publications'});
    }

    sourceIds = _.compact(sourceIds);

    var validator = new Validator();
    validator.check(sourceIds.length, {'code': 400, 'msg': 'No source ID\'s specified'}).min(1);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Create a new file with the Content API if a file is specified
    if (uploadedFile) {
        ContentAPI.createFile(ctx, publication.displayName, null, null, null, uploadedFile, function(err, contentObj) {
            if (err) {
                return callback({'code': err.code, 'msg': err.msg});
            }

            // Add the created resource ID to the publication object
            publication.linkedContentId = contentObj.id;
            return _createPublication(ctx, publication, sourceIds, callback);
        });
    } else {
        publication.linkedContentId = null;
        return _createPublication(ctx, publication, sourceIds, callback);
    }
};

/**
 * Ingests a publication after there has been checked if a file has been uploaded or not
 *
 * @param  {Object}         ctx                     The current context
 * @param  {Publication}    publication             The publication to create
 * @param  {String[]}       sourceIds               An array of source identifiers
 * @param  {Function}       callback                Standard callback method
 * @param  {Object}         callback.err            Standard error object
 * @param  {Object}         callback.publication    The ingested publication
 * @param  {String}         callback.result         The result of the ingestion process. This will be one of `PublicationsConstants.ingestionResult` and will indicate whether the publication has been created, updated or ignored
 * @api private
 */
var _createPublication = function(ctx, publication, sourceIds, callback) {

    // Ingest the publication
    IngesterAPI.ingestPublication(ctx.tenant().alias, publication, sourceIds, function(err, publication, result) {
        if (err) {
            return callback(err);
        }

        // Since we don't want to create a ticket for an updated publication, we just return the publication
        if (result !== PublicationsConstants.ingestionResult.CREATED) {
            return callback(null, publication, result);
        }

        // Keep track of how many listeners still need to return
        var numListeners = _.keys(createPublicationListeners).length;
        if (numListeners === 0) {
            return callback(null, publication);
        }

        /*!
         * Complete one iteration of the listeners loop. Will invoke the method callback when each listener was completed
         */
        var _listenerCompleted = function() {
            numListeners--;
            if (numListeners === 0) {

                // Return the created publication
                getPublication(ctx, publication.id, function(err, publication) {
                    if (err) {
                        return callback(err);
                    }

                    return callback(null, publication, result);
                });
            }
        };

        // When a publication is created, we want to run some decorators
        _.each(createPublicationListeners, function(listener, namespace) {
            createPublicationListeners[namespace](ctx, publication, function(err) {
                if (err) {
                    log().error({'err': err, 'namespace': namespace}, 'Error while executing a create publication listener during publication creation');
                    return callback(err);
                }

                return _listenerCompleted();
            });
        });
    });
};

/**
 * Links an OAE user to a publication. The authorname that is used in the set should be provided.
 * This does not necessarily have to be an exact match as some disambiguiation will be attempted.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     publicationId   The publication to link the user to
 * @param  {String}     authorName      The name of the user as its stored in the external system/on the publication
 * @param  {String}     userId          The OAE user ID to link
 * @param  {Function}   callback        Standard callback function
 */
var linkPublicationToUser = module.exports.linkPublicationToUser = function(ctx, publicationId, authorName, userId, callback) {
    if (!ctx.user()) {
        return callback({'code': 401, 'msg': 'Only authorized users are allowed to create publications'});
    }

    if (!ctx.user().isAdmin(ctx.tenant().alias) && ctx.user().id !== userId) {
        return callback({'code': 401, 'msg': 'You can only link your own user account to a publication'});
    }

    IngesterAPI.linkPublicationToUser(publicationId, authorName, userId, callback);
};

/**
 * Updates a publication
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}         publicationId           The publication ID (e.g p:cam:a1C2Hg5Qc1)
 * @param  {Object}         opts                    Object containing the updated publication fields
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object, if any
 * @param  {Publication}    callback.publication    The updated publication
 * @param  {String}         callback.result         The resul t of the ingestion process. This will be one of `PublicationsConstants.ingestionResult` and will indicate whether the publication has been created, updated or ignored
 */
var updatePublication = module.exports.updatePublication = function(ctx, publicationId, opts, callback) {

    // Check if valid parameters have been provided
    var validator = new PublicationsValidator();
    validator.check(publicationId, {'code': 400, 'msg': 'Missing or invalid publicationId'}).isPublicationId();

    var updates = _.keys(opts);
    validator.check(null, {'code': 400, 'msg': 'Missing or invalid changes'}).isObject(opts);
    validator.check(updates.length, {'code': 400, 'msg': 'Missing or invalid changes'}).min(1);
    _.each(opts, function(update) {
        validator.check(update, {'code': 400, 'msg': 'Missing or invalid changes'}).notNull();
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the user is allowed to edit the publication
    canManage(ctx, publicationId, function(err, canManage, publication) {
        if (err) {
            return callback(err);
        } else if (!canManage) {
            return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
        }

        // Update the publication
        PublicationsDAO.updatePublication(publicationId, opts.publication, function(err, publication) {
            if (err) {
                log().error({'code': err.code, 'msg': err.msg, 'publicationId': publicationId}, 'Error while updating publication');
                return callback(err);
            }

            return callback(null, publication, PublicationsConstants.ingestionResult.UPDATED);
        });
    });
};

//////////////////
//  RETRIEVAL   //
//////////////////

/**
 * Gets a publication by its ID
 *
 * @param  {Context}        ctx                     The current execution context
 * @param  {String}         publicationId           The ID of the publication to retrieve
 * @param  {Function}       callback                Standard callback method
 * @param  {Object}         callback.err            Standard error object
 * @param  {Publication}    callback.publication    The retrieved publication
 */
var getPublication = module.exports.getPublication = function(ctx, publicationId, callback) {
    var validator = new Validator();
    _validatePublicationId(validator, publicationId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    PublicationsDAO.getPublication(publicationId, function(err, publication) {
        if (err) {
            return callback(err);
        }

        // Add the user profile to the publication
        _augmentPublicationsWithUserProfiles(ctx, [publication], function(err, publications) {
            if (err) {
                return callback(err);
            }

            // Add the content profile to the publication
            _augmentPublicationsWithContentProfiles(ctx, publications, function(err, publications) {
                if (err) {
                    return callback(err);
                }

                // Decorate the publication with its decorators
                _augmentPublicationsWithDecorators(ctx, publications, function(err, publications) {
                    if (err) {
                        return callback(err);
                    }

                    return callback(null, publications[0]);
                });
            });
        });
    });
};

/**
 * Retrieves a set of publications for a user who created the publication
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}         userId                  The OAE user id for whom the publications should be retrieved
 * @param  {String}         start                   The publication ordering token from which to start fetching publications (see `nextToken` in callback params)
 * @param  {Number}         limit                   The amount of publications that should be retrieved
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object, if any
 * @param  {Publication[]}  callback.publications   The publications for that user. If there are any OAE users in the co-author list, it will list their OAE profile. Otherwise, the plain-text author string will be provided
 * @param  {String}         callback.nextToken      The value to provide in the `start` parameter to get the next set of results
 */
var getPublicationsByCreator = module.exports.getPublicationsByCreator = function(ctx, userId, start, limit, callback) {
    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'Missing or invalid userId'}).isUserId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    limit = OaeUtil.getNumberParam(limit, 25, 1);
    PublicationsDAO.getPublicationsByCreator(userId, start, limit, function(err, publications, nextToken) {
        if (err) {
            return callback(err);
        }

        if (publications.length === 0) {
            return callback(null, [], null);
        }

        // Add the user profiles of the authors that have an OAE user id to the publication
        _augmentPublicationsWithUserProfiles(ctx, publications, function(err, publications) {
            if (err) {
                return callback(err);
            }

            // Add the content profiles to the publications
            _augmentPublicationsWithContentProfiles(ctx, publications, function(err, publications) {
                if (err) {
                    return callback(err);
                }

                // Decorate the publications with their decorators
                _augmentPublicationsWithDecorators(ctx, publications, function(err, publications) {
                    if (err) {
                        return callback(err);
                    }

                    return callback(null, publications, nextToken);
                });
            });
        });
    });
};

/**
 * Retrieves a set of publications for a user who has been tagged as an author
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}         userId                  The OAE user id for whom the publications should be retrieved
 * @param  {String}         start                   The publication ordering token from which to start fetching publications (see `nextToken` in callback params)
 * @param  {Number}         limit                   The amount of publications that should be retrieved
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object, if any
 * @param  {Publication[]}  callback.publications   The publications for that user. If there are any OAE users in the co-author list, it will list their OAE profile. Otherwise, the plain-text author string will be provided
 * @param  {String}         callback.nextToken      The value to provide in the `start` parameter to get the next set of results
 */
var getPublicationsForUser = module.exports.getPublicationsForUser = function(ctx, userId, start, limit, callback) {
    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'Missing or invalid userId'}).isUserId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    limit = OaeUtil.getNumberParam(limit, 25, 1);
    PublicationsDAO.getPublicationsForUser(userId, start, limit, function(err, publications, nextToken) {
        if (err) {
            return callback(err);
        }

        if (publications.length === 0) {
            return callback(null, [], null);
        }

        // Add the user profiles of the authors that have an OAE user id to the publication
        _augmentPublicationsWithUserProfiles(ctx, publications, function(err, publications) {
            if (err) {
                return callback(err);
            }

            // Add the content profiles to the publications
            _augmentPublicationsWithContentProfiles(ctx, publications, function(err, publications) {
                if (err) {
                    return callback(err);
                }

                // Decorate the publications with their decorators
                _augmentPublicationsWithDecorators(ctx, publications, function(err, publications) {
                    if (err) {
                        return callback(err);
                    }

                    return callback(null, publications, nextToken);
                });
            });
        });
    });
};

/**
 * Adds the content profiles to the publications
 *
 * @param  {RestContext}        ctx                     The current execution context
 * @param  {Publication[]}      publictions             The publications which need to be augemented with the content profiles
 * @param  {Function}           callback                Standard callback function
 * @param  {Object}             callback.err            Error object containing the error message
 * @param  {Publication[]}      callback.publications   The augmented publications
 * @api private
 */
var _augmentPublicationsWithContentProfiles = function(ctx, publications, callback) {

    // Fetch al the content ID's
    var contentIds = [];
    _.each(publications, function(publication) {
        if (publication.linkedContentId) {
            contentIds.push(publication.linkedContentId);
        }
    });

    // Get the content item profiles
    ContentDAO.getMultipleContentItems(contentIds, null, function(err, contentObjs) {
        if (err) {
            return callback(err);
        }

        // Add the content profiles to the publication profile
        _.each(contentObjs, function(contentObj) {
            ContentUtil.augmentContent(ctx, contentObj);
        });

        _.each(publications, function(publication) {
            var contentObj = _.find(contentObjs, function(contentObj) { return contentObj.id === publication.linkedContentId; } );
            publication.linkedContent = contentObj;
        });

        return callback(null, publications);
    });
};

/**
 * Replaces any user IDs in the set of authors with their full OAE profile
 *
 * @param  {RestContext}        ctx                     The current execution context
 * @param  {Publication[]}      publications            A set of publications
 * @param  {Function}           callback                Standard callback method
 * @param  {Object}             callback.err            Standard error object
 * @param  {Publication[]}      callback.publications   The augmented publications
 * @api private
 */
var _augmentPublicationsWithUserProfiles = function(ctx, publications, callback) {
    // Get the users who co-authored some of these publications
    var userIds = [];
    _.each(publications, function(publication) {
        userIds = userIds.concat(publication.authors);
    });

    userIds = _.chain(userIds).uniq().compact().filter(function(userId) {
        return AuthzUtil.isUserId(userId);
    }).value();

    PrincipalsUtil.getPrincipals(ctx, userIds, function(err, principals) {
        if (err) {
            return callback(err);
        }

        _.each(publications, function(publication) {
            var authors = [];
            _.each(publication.authors, function(authorId) {
                var principal = _.find(principals, function(principal, principalId) { return principalId === authorId; });
                if (principal) {
                    authors.push(principal);
                } else {
                    authors.push(authorId);
                }
            });
            publication.authors = authors;
        });

        return callback(null, publications);
    });
};

/**
 * Decorates a collection of publications
 *
 * @param  {Context}        ctx                     Standard context object, representing the currently logged in user and its tenant
 * @param  {Publication[]}  publications            Collection of publications to decorate
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error object containing the error object and the error message
 * @param  {Publication[]}  callback.publications   Collection of decorated publications
 * @api private
 */
var _augmentPublicationsWithDecorators = function(ctx, publications, callback) {

    // Keep track of how many listeners still need to return
    var numDecorators = _.keys(publicationsProfileDecorators).length;
    if (numDecorators === 0) {
        log().error({'err': err}, 'Error when invoking a publication decorator');
        return callback(null, publications);
    }

    /*!
     * Complete one iteration of the listeners loop. Will invoke the method callback when each listener is completed
     */
    var _finishDecorator = function() {
        numDecorators--;
        if (numDecorators === 0) {
            return callback(null, publications);
        }
    };

    // When a publication is created, we want to run some decorators
    _.each(publicationsProfileDecorators, function(decorator, namespace) {
        decorator(ctx, publications, function(err, publications) {
            if (err) {
                log().error({'err': err, 'namespace': namespace}, 'Error when invoking a publication decorator');
                return callback(err);
            }

            return _finishDecorator();
        });
    });
};

/////////////////////
//  AUTHORIZATION  //
/////////////////////

/**
 * Check whether or not the current user can manage a publication
 *
 * @param  {Context}        ctx                     Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         publicationID           The id of the publication object we want to check
 * @param  {Function}       callback                Standard callback function takes arguments `err`, `canManage`, and `content`
 * @param  {Object}         callback.err            Error object containing the error message
 * @param  {Boolean}        callback.canManage      Whether or not the user can manage the content
 */
var canManage = module.exports.canManage = function(ctx, publicationId, callback) {
    var validator = new PublicationsValidator();
    validator.check(publicationId, {'code': 400, 'msg': 'A content id must be provided'}).isPublicationId();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to manage content'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    PublicationsDAO.getPublication(publicationId, function(err, publication) {
        if (err) {
            if (err.code === 401) {
                return callback(null, false);
            } else {
                return callback(err);
            }
        }

        return callback(null, _canManage(ctx, publication), publication);
    });
};

/**
 * Internal function that checks whether or not the current user can manage a piece of content. This function assumes that
 * the piece of content passed in actually exists
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {Content}        publication         The publication object we want to check
 * @return {Boolean}                            Whether or not the user is allowed to manage the content
 * @api private
 */
var _canManage = function(ctx, publication) {
    if (!ctx.user()) {
        return false;
    }

    // Check if the current user is a global admin
    if (ctx.user().isGlobalAdmin()) {
        return true;
    }

    // Check if the current user is the author OR the user is the admin of one of the authors
    for (var i=0; i<publication.authors.length; i++) {
        if (publication.authors[i] === ctx.user().id || _isUserAdmin(ctx.user(), publication.authors[0])) {
            return true;
        }
    }

    return false;
};

/**
 * Check if the current user is an admin of the author's tenant
 *
 * @param  {User}           currentUser         Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         author              The author of the publication
 * @return {Boolean}                            Whether the current user is an admin or not
 * @api private
 */
var _isUserAdmin = function(currentUser, author) {
    if (AuthzUtil.isUserId(author)) {
        var tenantAlias = AuthzUtil.getPrincipalFromId(author).tenantAlias;
        return currentUser.isAdmin(tenantAlias);
    }
    return false;
};

/**
 * Because publication IDs aren't tied to a tenant we can't use the typical resource ID validator.
 * This method will validate the given publication ID with the other available methods on the validator object.
 *
 * @param  {Validator}  validator       A validator instance
 * @param  {String}     publicationId   The publication ID to validate
 * @api private
 */
var _validatePublicationId = function(validator, publicationId) {
    validator.check(publicationId, {'code': 400, 'msg': 'Missing publicationId'}).notEmpty();
    if (publicationId) {
        validator.check(publicationId[0], {'code': 400, 'msg': 'Malformed publicationId'}).is('p');
    }
};
