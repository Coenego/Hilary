/*!
 * Copyright 2014 Digital Services, University of Cambridge Licensed
 * under the Educational Community License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('oae-tickets');

var TicketsUtil = require('../util');

/**
 * Creates a new ticket
 *
 * @param  {String}     ticketId                    The ticket id
 * @param  {Object}     parameters                  Object containing ticket fields
 * @param  {String}     parameters.tenantAlias      The alias of the tenant where the ticket was created in
 * @param  {String}     parameters.createdBy        The ID of the user that created the ticket
 * @param  {String}     parameters.publicationId    The ID of the publication
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                The thrown error, if any
 * @param  {Ticket}     callback.ticket             The created ticket
 */
var createTicket = module.exports.createTicket = function(ticketId, parameters, callback) {
    var publicationId = parameters.publicationId;

    // Check if the publication hasn't already been linked to a ticket
    getTicketByPublicationId(parameters.publicationId, function(err, result) {
        if (err) {
            return callback(err);
        }

        if (result) {
            log().error({'code': 400, 'msg': 'The publication has already been linked to a ticket'}, 'Error while creating ticket for publication');
            return callback({'code': 400, 'msg': 'The publication has already been linked to a ticket'});
        }

        // Collection of Cassandra queries
        var queries = [];

        // Construct a query that creates a new ticket
        parameters = _.extend(parameters, {'created': Date.now(), 'lastModified': Date.now()});
        queries.push(Cassandra.constructUpsertCQL('Tickets', 'ticketId', ticketId, parameters));

        // Construct a query that creates a record of a publication linked to a ticket
        parameters = {'ticketId': ticketId};
        queries.push(Cassandra.constructUpsertCQL('TicketsByPublication', 'publicationId', publicationId, parameters));

        // Send the queries off to cassandra
        Cassandra.runBatchQuery(queries, function(err) {
            if (err) {
                log().error({'code': err.code, 'msg': err.msg}, 'Error while creating ticket');
                return callback(err);
            }

            // Return the created ticket
            getTicket(ticketId, function(err, ticket) {
                if (err) {
                    return callback(err);
                }

                return callback(null, ticket);
            });
        });
    });
};

/**
 * Returns a ticket
 *
 * @param  {String}     ticketId            The id of the ticket that needs to be returned
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing error code and error message
 * @param  {Ticket}     callback.ticket     The requested ticket
 */
var getTicket = module.exports.getTicket = function(ticketId, callback) {
    Cassandra.runQuery('SELECT * FROM "Tickets" WHERE "ticketId" = ?', [ticketId], function(err, rows) {
        if (err) {
            log().error({'code': err.code, 'ticketId': ticketId, 'msg': err.msg}, 'Error while requesting ticket');
            return callback(err);
        }

        // Return an error if the requested ticket was not found
        if (!rows.length) {
            return callback({'code': 404, 'msg': 'The requested ticket was not found'});
        }

        var ticket = TicketsUtil.rowToTicket(rows[0]);
        return callback(null, ticket);
    });
};

/**
 * Returns a collection of tickets
 *
 * @param  {String[]}   ticketIds           Collection of ticket ID's
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing error code and error message
 * @param  {Ticket[]}   callback.tickets    Array containing a ticket object for each available ticket for the user
 */
var getTickets = module.exports.getTickets = function(ticketIds, callback) {
    Cassandra.runQuery('SELECT * FROM "Tickets" WHERE "ticketId" IN (?)', [ticketIds], function(err, rows) {
        if (err) {
            log().error({'code': err.code, 'msg': err.msg}, 'Error while requesting tickets');
            return callback(err);
        }

        // Return an error if no tickets were found
        if (!rows.length) {
            return callback({'code': 404, 'msg': 'The requested tickets were not found'});
        }

        var tickets = TicketsUtil.rowsToTickets(rows);
        return callback(null, tickets);
    });
};

/**
 * Check if a publication is linked to a ticket
 *
 * @param  {String}     publicationId       The publication ID
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containg error code and error message
 * @param  {Ticket}     callback.ticket     The ticket that corresponds with the publication (if any)
 */
var getTicketByPublicationId = module.exports.getTicketByPublicationId = function(publicationId, callback) {
    Cassandra.runQuery('SELECT * FROM "TicketsByPublication" WHERE "publicationId" = ?', [publicationId], function(err, rows) {
        if (err) {
            log().error({'code': err.code, 'msg': err.msg}, 'Error while checking publication ticket');
            return callback(err);
        }

        // Return an empty result if the ticket was not found
        if (!rows.length) {
            return callback();
        }

        // Return the ticket
        var publicationTicket = TicketsUtil.rowToPublicationTicket(rows[0]);
        getTicket(publicationTicket.ticketId, function(err, ticket) {
            if (err) {
                return callback(err);
            }

            return callback(null, ticket);
        });
    });
};

/**
 * Return a collection of tickets based on their linked publication ID's
 *
 * @param  {String[]}   publicationId       Collection of publication ID's
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containg error code and error message
 * @param  {Ticket[]}   callback.tickets    The tickets that correspond with the publication ID's (if any)
 */
var getTicketsByPublicationIds = module.exports.getTicketsByPublicationIds = function(publicationIds, callback) {
    Cassandra.runQuery('SELECT * FROM "TicketsByPublication" WHERE "publicationId" IN (?)', [publicationIds], function(err, rows) {
        if (err) {
            log().error({'code': err.code, 'msg': err.msg}, 'Error while checking publication ticket');
            return callback(err);
        }

        // Return an error if no matching tickets were found
        if (!rows.length) {
            return callback({'code': 404, 'msg': 'No matching tickets found for any of the publication ID\'s'});
        }

        var ticketIds = TicketsUtil.rowsToPublicationTickets(rows);
        ticketIds = _.map(TicketsUtil.rowsToPublicationTickets(rows), function(row) { return row.ticketId; });

        // Return an error if no matching tickets were found
        if (!ticketIds.length) {
            return callback({'code': 404, 'msg': 'No matching tickets found for any of the publication ID\'s'});
        }

        // Retrieve all the tickets by their ticket ID
        getTickets(ticketIds, function(err, tickets) {
            if (err) {
                return callback({'code': 404, 'msg': 'No matching tickets found for any of the publication ID\'s'});
            }

            return callback(null, tickets);
        });
    });
};

/**
 * Return the current tickets counter value
 *
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            Error object containing error code and error message
 * @param  {String}     callback.counterValue   The current counter value
 */
var getTicketsCounter = module.exports.getTicketsCounter = function(callback) {

    // Run the Cassandra query that returns the current counter value
    Cassandra.runQuery('SELECT "value" FROM "TicketsCounter" WHERE "name" = ?', ['tickets'], function(err, rows) {
        if (err) {
            log().error(err);
            return callback(err);
        }

        if (!rows.length) {
            return callback(null, 0);
        }

        var row = Cassandra.rowToHash(rows[0]);
        var value = row.value;

        return callback(null, value);
    });
};

/**
 * Increase the tickets counter value
 *
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.er             Error object containing error code and error message
 * @param  {String}     callback.counterValue   The current counter value after update
 */
var increaseTicketsCounter = module.exports.increaseTicketsCounter = function(callback) {

    // Run the Cassandra query that increases the counter value
    Cassandra.runQuery('UPDATE "TicketsCounter" SET value = value + 1 WHERE "name" = ?', ['tickets'], function(err) {
        if (err) {
            log().error(err);
            return callback(err);
        }

        return getTicketsCounter(callback);
    });
};
