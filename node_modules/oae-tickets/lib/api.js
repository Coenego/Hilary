/*!
 * Copyright 2014 Digital Services, University of Cambridge Licensed
 * under the Educational Community License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var util = require('util');
var ShortId = require('shortid');

var AuthzUtil = require('oae-authz/lib/util');
var Locking = require('oae-util/lib/locking');
var log = require('oae-logger').logger('oae-tickets');
var PublicationsAPI = require('oae-publications').Publications;
var PublicationsDAO = require('oae-publications/lib/internal/dao');
var PublicationsValidator = require('oae-publications/lib/validator').Validator;
var Validator = require('oae-util/lib/validator').Validator;

var TicketsConstants = require('./constants').TicketsConstants;
var TicketsDAO = require('./internal/dao');
var TicketsEmitter = require('./internal/emitter');
var TicketsValidator = require('./validator').Validator;

/**
 * Register a listener in the publications API for when a publication has been created
 */
PublicationsAPI.registerCreatePublicationListener('ticket', function(ctx, publication, callback) {
    return createTicket(ctx, publication.id, callback);
});

/**
 * Register a decorator that adds the ticket information to the publication profile
 */
PublicationsAPI.registerPublicationsDecorator('ticket', function(ctx, publications, callback) {
    return _addTicketsToPublications(ctx, publications, callback);
});

/**
 * Create a new ticket
 *
 * @param  {Object}     ctx                 The current context
 * @param  {String}     pubicationId        The id of the publication that was created
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing error code and error message
 * @param  {Ticket}     callback.ticket     Object representing the created ticket
 * @api private
 */
var createTicket = module.exports.createTicket = function(ctx, publicationId, callback) {
    var validator = new PublicationsValidator();
    validator.check(publicationId, {'code': 400, 'msg': 'A valid publication ID must be provided'}).isPublicationId();
    if (validator.hasErrors()) {
        log().error({'code': validator.getFirstError().code, 'err': validator.getFirstError().msg, 'publicationId': publicationId}, 'Error while creating new ticket');
        return callback(validator.getFirstError());
    }

    // Store the tenant alias
    var tenantAlias = ctx.tenant().alias;

    // Check if the specified publication exists
    PublicationsDAO.getPublication(publicationId, function(err, publication) {
        if (err && err.code !== 404) {
            return callback(err);
        }

        if (!publication) {
            log().error({'code': 404, 'msg': 'The publication could not be found', 'publicationId': publicationId}, 'The publication could not be found');
            return callback({'code': 404, 'msg': 'The publication could not be found'});
        }

        // Check if the current user is allowed to create a ticket for the publication
        if (!_canManage(ctx, publication)) {
            return callback({'code': 401, 'msg': 'Only authorized admins are allowed to request tickets'});
        }

        // Keep track of the attempts to create a ticket
        var createTicketAttempts = 0;

        // Key that is used to lock the current cycle
        var key = util.format('oae-tickets:counter:%s', tenantAlias);

        /*!
         * To prevent a duplication of ticket ID's we need to lock the current ticket ID untill the ticket has been created
         * TODO: We need to find a way to store information or give feedback to the user that a ticket has NOT been created when failing...
         */
        var _createTicket = function() {

            /*!
             * Release the lock on the `counter` key
             *
             * @param  {String}     lockToken       The lock token
             * @param  {Object}     [err]           The thrown error, if any
             * @param  {Ticket}     [ticket]        The generated ticket, if no error occurred
             * @api private
             */
            var _releaseLocking = function(lockToken, err, ticket) {
                createTicketAttempts = 0;
                Locking.release(key, lockToken, function(lockErr) {
                    err = err || lockErr;
                    if (err) {
                        return callback(err);
                    }

                    TicketsEmitter.emit(TicketsConstants.events.CREATED_TICKET, ctx, ticket);
                    return callback(null, ticket);
                });
            };

            // Lock the key
            Locking.acquire(key, 15, function(err, lockToken) {
                createTicketAttempts++;
                if (err || !lockToken) {
                    if (createTicketAttempts < 10) {
                        return _createTicket();
                    }

                    log().error({'code': 400, 'msg': util.format('Unable to create ticket for publication: "%s"', publicationId)});
                    return callback({'code': 400, 'msg': 'Unable to create ticket for publication'});
                }

                // Increase the current counter value
                TicketsDAO.increaseTicketsCounter(tenantAlias, function(err, counterValue) {
                    if (err) {
                        log().error({'err': err},'Error while creating ticket ID');
                        return _releaseLocking(lockToken, err);
                    }

                    var ticketId = _generateTicketId(tenantAlias);
                    var externalId = 'OA-' + counterValue;
                    var createdBy = ctx.user().id;

                    // Create the ticket
                    TicketsDAO.createTicket(ticketId, externalId, publicationId, tenantAlias, createdBy, function(err, ticket) {
                        if (err) {
                            log().error({'code': err.code, 'msg': err.msg, 'ticketId': ticketId}, 'Error while creating a ticket');
                            return _releaseLocking(lockToken, err);
                        }

                        // Release the key
                        return _releaseLocking(lockToken, null, ticket);
                    });
                });
            });
        };

        _createTicket();
    });
};

/**
 * Deletes a specific ticket
 *
 * @param  {Object}     ctx                 The current context
 * @param  {String}     ticketId            The id of the ticket that needs to be deleted
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing error code and error message
 * @param  {Ticket}     callback.ticket     Object representing the deleted ticket
 */
var deleteTicket = module.exports.deleteTicket = function(ctx, ticketId, callback) {
    var validator = new Validator();
    validator.check(ticketId, {'code': 400, 'msg': 'No ticket ID specified'}).notEmpty();
    validator.check(ticketId, {'code': 400, 'msg': 'invalid ticket ID specified'}).isShortString();
    validator.check(ticketId, {'code': 400, 'msg': 'A valid ticket ID must be provided'}).isTicketId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    if(!_canDelete(ctx, ticketId)) {
        return callback({'code': 401, 'msg': 'Only authorized users are allowed to delete tickets'});
    }

    // Check if the ticket exists
    TicketsDAO.getTicket(ticketId, function(err, ticket) {
        if (err) {
            return callback(err);
        }

        // Delete the ticket
        TicketsDAO.deleteTicket(ticketId, ticket.publicationId, function(err) {
            if (err) {
                return callback(err);
            }

            TicketsEmitter.emit(TicketsConstants.events.DELETED_TICKET, ticket);
            return callback(null, ticket);
        });
    });
};

/**
 * Returns a specific ticket
 *
 * @param  {String}     ticketId            The id of the ticket that needs to be returned
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing error code and error message
 * @param  {Ticket}     callback.ticket     Object representing the requested ticket
 */
var getTicket = module.exports.getTicket = function(ticketId, callback) {
    var validator = new TicketsValidator();
    validator.check(ticketId, {'code': 400, 'msg': 'No ticket ID specified'}).notEmpty();
    validator.check(ticketId, {'code': 400, 'msg': 'invalid ticket ID specified'}).isShortString();
    validator.check(ticketId, {'code': 400, 'msg': 'A valid ticket ID must be provided'}).isTicketId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Return a specified ticket
    TicketsDAO.getTicket(ticketId, function(err, ticket) {
        if (err) {
            return callback(err);
        }

        return callback(null, ticket);
    });
};

/**
 * Returns a collection of tickets, specified by their ID's
 *
 * @param  {String[]}   ticketIds           Collection of ticket ID's
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing error code and error message
 * @param  {Ticket[]}   callback.tickets    Array containing a ticket object for each available ticket for the user
 */
var getTickets = module.exports.getTickets = function(ticketIds, callback) {
    if (!_.isArray(ticketIds)) {
        ticketIds = [ ticketIds ];
    }

    // Validate the provided parameters
    var validator = new Validator();
    validator.check(ticketIds, {'code': 400, 'msg': 'No ticket ID\'s specified'}).notEmpty();
    if (ticketIds) {
        validator.check(ticketIds.length, {'code': 400, 'msg': 'Invalid number of ticket ID\'s specified'}).min(1);
        _.each(ticketIds, function(ticketId) {
            validator.check(ticketId, {'code': 400, 'msg': 'Invalid ticket ID specified'}).isTicketId();
        });
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Return a collection of tickets
    return TicketsDAO.getTickets(ticketIds, callback);
};

/**
 * Updates a ticket
 *
 * @param  {String}     ticketId            The id of the ticket that needs to be updated
 * @param  {Object}     opts                Object containing the ticket parameters that need to be updated
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing error code and error message
 * @param  {Ticket}     callback.ticket     Object representing the updated ticket
 */
var updateTicket = module.exports.updateTicket = function(ticketId, opts, callback) {
    var validator = new Validator();
    validator.check(ticketId, {'code': 400, 'msg': 'No ticket ID specified'}).notEmpty();
    validator.check(ticketId, {'code': 400, 'msg': 'invalid ticket ID specified'}).isShortString();
    validator.check(ticketId, {'code': 400, 'msg': 'A valid ticket ID must be provided'}).isTicketId();
    validator.check(null, {'code': 400, 'msg': 'Missing or invalid updates for ticket'}).isObject(opts);
    _.each(_.keys(opts), function(key) {
        if (key !== 'status' && key !== 'lastModified') {
            delete opts[key];
        }
    });
    validator.check(_.keys(opts).length, {'code': 400, 'msg': 'Missing or invalid updates for ticket'}).min(1);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the ticket exists
    TicketsDAO.getTicket(ticketId, function(err, ticket) {
        if (err) {
            return callback(err);
        }

        // Update the ticket
        TicketsDAO.updateTicket(ticketId, opts, function(err) {
            if (err) {
                return callback(err);
            }

            // Return the updated ticket
            TicketsEmitter.emit(TicketsConstants.events.UPDATED_TICKET, ticket);
            return getTicket(ticketId, callback);
        });
    });
};

//////////////////////////
//  INTERNAL FUNCTIONS  //
//////////////////////////

/**
 * Add the corresponding ticket to a publication
 *
 * @param  {Context}            ctx                         The current context
 * @param  {Publication[]}      publications                A collection of publications that need to be decorated
 * @param  {Function}           callback                    Standard callback function
 * @param  {Object}             callback.err                Error object containing the error code and error message
 * @param  {Publication[]}      callback.publications       A collection of decorated publications
 * @api private
 */
var _addTicketsToPublications = function(ctx, publications, callback) {

    // Filter the publication ID's from the collection
    var publicationIds = _.pluck(publications, 'id');

    // Request the tickets corresponding to the publication ID's
    TicketsDAO.getTicketsByPublicationIds(publicationIds, function(err, tickets) {
        if (err && err.code !== 404) {
            log().error({'code': err.code, 'msg': err.msg}, 'Error while requesting tickets by publication ID\'s');
            return callback(err);
        }

        // Decorate each publication with its corresponding ticket
        _.each(publications, function(publication) {
            if (_canManage(ctx, publication)) {
                publication.ticket = _.find(tickets, function(ticket) { return ticket.publicationId === publication.id; });
            }
        });

        // Return the decorated publications
        return callback(null, publications);
    });
};

/**
 * Verifies whether or not the user is allowed to delete a ticket
 *
 * @param  {Object}         ctx                 The current context
 * @param  {String}         ticketId            The id of the ticket that needs to be deleted
 * @return {Boolean}                            Whether the current user is allowed to delete a ticket or not
 * @api private
 */
var _canDelete = function(ctx, ticketId) {
    if (!ctx.user()) {
        return false;
    }

    return ctx.user().isAdmin(ticketId.split(':')[1]);
};

/**
 * Verifies that the current user is allowed to create a new ticket
 *
 * @param  {Object}         ctx                 The current context
 * @param  {Publication}    publication         The publication where a ticket needs to be created
 * @return {Boolean}                            Whether the current user is allowed to create a ticket or not
 * @api private
 */
var _canManage = function(ctx, publication) {
    if (!ctx.user()) {
        return false;
    }

    // Global admins and admins where the publication was created in are always allowed to create tickets
    if (ctx.user().isGlobalAdmin() || ctx.user().isAdmin(publication.tenantAlias)) {
        return true;
    }

    // The creator and the authors of the publication are allowed to create tickets
    if (ctx.user().id === publication.createdBy) {
        return true;
    }

    // Authors of the publication should be able to create a ticket
    if (_.find(publication.authors, function(author) { return (author.id === ctx.user().id || author === ctx.user().id); })) {
        return true;
    }

    return false;
};

 /**
 * Generates a new ticket ID.
 *
 * @param  {String}     tenantAlias     The tenant alias for the ticket
 * @return {String}                     The new ticket ID
 * @api private
 */
var _generateTicketId = function(tenantAlias) {
    return AuthzUtil.toId('t', tenantAlias, ShortId.generate());
};
