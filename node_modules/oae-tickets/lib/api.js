/*!
 * Copyright 2014 Digital Services, University of Cambridge Licensed
 * under the Educational Community License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var util = require('util');

var ConfigAPI = require('oae-config');
var Locking = require('oae-util/lib/locking');
var log = require('oae-logger').logger('oae-tickets');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var PublicationsAPI = require('oae-publications');
var PublicationsValidator = require('oae-publications/lib/validator').Validator;
var TenantsAPI = require('oae-tenants');
var Validator = require('oae-util/lib/validator').Validator;

var TicketsConfig = ConfigAPI.config('oae-tickets');
var TicketsConstants = require('./constants').TicketsConstants;
var TicketsDAO = require('./internal/dao');
var TicketsEmitter = require('./internal/emitter');
var TicketsUtil = require('./util');
var TicketsValidator = require('./validator').Validator;

/**
 * Register a listener in the publications API for when a publication has been created
 */
PublicationsAPI.registerCreatePublicationListener('ticket', function(ctx, publication, callback) {
    return createTicket(ctx, null, publication.id, callback);
});

/**
 * Register a decorator that adds the ticket information to the publication profile
 */
PublicationsAPI.registerPublicationsDecorator('ticket', function(ctx, publicationId, callback) {
    return TicketsDAO.getTicketByPublicationId(publicationId, callback);
});

/**
 * Create a new ticket
 *
 * @param  {Object}     ctx                 The current context
 * @param  {String}     tenantAlias         The alias of the tenant where the ticket was created in
 * @param  {String}     pubicationId        The id of the publication that was created
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing error code and error message
 * @param  {Ticket}     callback.ticket     Object representing the created ticket
 * @api private
 */
var createTicket = module.exports.createTicket = function(ctx, tenantAlias, publicationId, callback) {
    if (!ctx.user()) {
        return callback({'code': 401, 'msg': 'Only authorized admins are allowed to request tickets'});
    }

    tenantAlias = tenantAlias || ctx.tenant().alias;
    if (!tenantAlias) {
        return callback({'code': 400, 'msg': 'Invalid or no tenantAlias specified'});
    }

    // Check if the Tickets module is enabled for the tenant
    if (!TicketsConfig.getValue(tenantAlias, 'general', 'enabled')) {
        return callback({'code': 401, 'msg': 'Tickets are not enabled for tenant'});
    }

    var validator = new PublicationsValidator();
    validator.check(publicationId, {'code': 400, 'msg': 'A valid publication ID must be provided'}).isPublicationId();
    if (validator.hasErrors()) {
        log().error({'code': validator.getFirstError().code, 'err': validator.getFirstError().msg, 'publicationId': publicationId}, 'Error while creating new ticket');
        return callback(validator.getFirstError());
    }

    // Check if the specified publication exists
    PublicationsAPI.getPublication(ctx, publicationId, function(err, publication) {
        if (err && err.code !== 404) {
            return callback(err);
        }

        if (!publication) {
            log().error({'code': 404, 'msg': 'The publication could not be found', 'publicationId': publicationId}, 'The publication could not be found');
            return callback({'code': 404, 'msg': 'The publication could not be found'});
        }

        // Keep track of the attempts to create a ticket
        var createTicketAttempts = 0;

        // Key that is used to lock the current cycle
        var key = 'oae-tickets:counter';

        /*!
         * To prevent a duplication of ticket ID's we need to lock the current ticket ID untill the ticket has been created
         */
        var _createTicket = function() {

            /*!
             * Release the lock on the `counter` key
             *
             * @param  {String}     lockToken       The lock token
             * @param  {Object}     [err]           The thrown error, if any
             * @param  {Ticket}     [ticket]        The generated ticket, if no error occurred
             * @api private
             */
            var _releaseLocking = function(lockToken, err, ticket) {
                createTicketAttempts = 0;
                Locking.release(key, lockToken, function(err) {
                    if (err) {
                        return callback(err);
                    }
                    TicketsEmitter.emit(TicketsConstants.events.CREATED_TICKET, ctx, ticket);
                    return callback(null, ticket);
                });
            };

            // Lock the key
            Locking.acquire(key, 15, function(err, lockToken) {
                createTicketAttempts++;
                if (err) {
                    if (createTicketAttempts < 10) {
                        return _createTicket();
                    }
                    return _releaseLocking(lockToken, {'code': 400, 'msg': util.format('Unable to create ticket for publication: "%s"', publicationId)});
                }

                // Increase the current counter value
                TicketsDAO.increaseTicketsCounter(function(err, counterValue) {
                    if (err) {
                        _releaseLocking(lockToken, err);
                    }

                    var ticketId = TicketsUtil.generateTicketId(tenantAlias);
                    var parameters = {
                        'externalId': 'OA-' + counterValue,
                        'tenantAlias': tenantAlias,
                        'createdBy': ctx.user().id,
                        'publicationId': publicationId
                    };

                    // Create the ticket
                    TicketsDAO.createTicket(ticketId, parameters, function(err, ticket) {
                        if (err) {
                            _releaseLocking(lockToken, err);
                        }

                        // Release the key
                        return _releaseLocking(lockToken, null, ticket);
                    });
                });
            });
        };

        _createTicket();
    });
};

/**
 * Returns a specific ticket
 *
 * @param  {Object}     ctx                 The current context
 * @param  {String}     ticketId            The id of the ticket that needs to be returned
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing error code and error message
 * @param  {Ticket}     callback.ticket     The requested ticket
 */
var getTicket = module.exports.getTicket = function(ctx, ticketId, callback) {
    var validator = new TicketsValidator();
    validator.check(ticketId, {'code': 400, 'msg': 'A valid ticket ID must be provided'}).isTicketId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    if (!_canManage(ctx, ticketId)) {
        return callback({'code': 401, 'msg': 'Only authorized administrators are allowed to request tickets'});
    }

    // Return a specified ticket
    TicketsDAO.getTicket(ticketId, function(err, ticket) {
        if (err) {
            return callback(err);
        }

        // Add the creator's profile to the ticket
        return _augmentTicketProfileWithCreatorProfile(ticket, callback);
    });
};

/**
 * Returns a collection of tickets, specified by their ID's
 *
 * @param  {Object}     ctx                 The current context
 * @param  {String[]}   ticketIds      Collection of ticket ID's
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing error code and error message
 * @param  {Ticket[]}   callback.tickets    Array containing a ticket object for each available ticket for the user
 */
var getTickets = module.exports.getTickets = function(ctx, ticketIds, callback) {
    if (!_.isArray(ticketIds)) {
        ticketIds = [ ticketIds ];
    }

    var validator = new Validator();
    validator.check(ticketIds.length, {'code': 400, 'msg': 'No ticket ID\'s specified'}).min(1);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Return a collection of tickets
    return TicketsDAO.getTickets(ticketIds, callback);
};

//////////////////////////
//  INTERNAL FUNCTIONS  //
//////////////////////////

/**
 * Add the profile of the creator to the ticket
 *
 * @param  {Ticket}     ticket              The ticket that has to be decorated with the creator's profile
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing error code and error message
 * @param  {User}       callback.ticket    The profile of the user that created the ticket
 * @api private
 */
var _augmentTicketProfileWithCreatorProfile = function(ticket, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 400, 'msg': 'Missing ticket when adding the creator\'s profile'}).isObject(ticket);
    if (ticket) {
        validator.check(ticket.createdBy, {'code': 400, 'msg': 'Missing ticket specified when adding the creator\'s profile'}).notEmpty();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Add the creator's profile to the ticket
    PrincipalsDAO.getPrincipal(ticket.createdBy, function(err, principal) {
        if (err) {
            return callback(err);
        }

        ticket.creator = principal;
        return callback(null, ticket);
    });
};

/**
 * Verifies if the current user is allowed to edit the ticket
 *
 * @param  {Object}     ctx                 The current context
 * @param  {String}     ticketId            The identifier of the ticket
 * @return {Boolean}                        Whether the user is allowed to edit the ticket or not
 * @api private
 */
var _canManage = function(ctx, ticketId) {
    return (ctx.user() && ctx.user().isAdmin(ticketId.split(':')[1]));
};
